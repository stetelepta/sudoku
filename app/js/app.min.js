(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
var existed = false;
var old;

if ('smokesignals' in global) {
    existed = true;
    old = global.smokesignals;
}

require('./smokesignals');

module.exports = smokesignals;

if (existed) {
    global.smokesignals = old;
}
else {
    delete global.smokesignals;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./smokesignals":2}],2:[function(require,module,exports){
smokesignals = {
    convert: function(obj, handlers) {
        // we store the list of handlers as a local variable inside the scope
        // so that we don't have to add random properties to the object we are
        // converting. (prefixing variables in the object with an underscore or
        // two is an ugly solution)
        // we declare the variable in the function definition to use two less
        // characters (as opposed to using 'var ').  I consider this an inelegant
        // solution since smokesignals.convert.length now returns 2 when it is
        // really 1, but doing this doesn't otherwise change the functionallity of
        // this module, so we'll go with it for now
        handlers = {};

        // add a listener
        obj.on = function(eventName, handler) {
            // either use the existing array or create a new one for this event
            (handlers[eventName] || (handlers[eventName] = []))
                // add the handler to the array
                .push(handler);

            return obj;
        }

        // add a listener that will only be called once
        obj.once = function(eventName, handler) {
            // create a wrapper listener, that will remove itself after it is called
            function wrappedHandler() {
                // remove ourself, and then call the real handler with the args
                // passed to this wrapper
                handler.apply(obj.off(eventName, wrappedHandler), arguments);
            }
            // in order to allow that these wrapped handlers can be removed by
            // removing the original function, we save a reference to the original
            // function
            wrappedHandler.h = handler;

            // call the regular add listener function with our new wrapper
            return obj.on(eventName, wrappedHandler);
        }

        // remove a listener
        obj.off = function(eventName, handler) {
            // loop through all handlers for this eventName, assuming a handler
            // was passed in, to see if the handler passed in was any of them so
            // we can remove it
            for (var list = handlers[eventName], i = 0; handler && list && list[i]; i++) {
                // either this item is the handler passed in, or this item is a
                // wrapper for the handler passed in.  See the 'once' function
                list[i] != handler && list[i].h != handler ||
                    // remove it!
                    list.splice(i--,1);
            }
            // if i is 0 (i.e. falsy), then there are no items in the array for this
            // event name (or the array doesn't exist)
            if (!i) {
                // remove the array for this eventname (if it doesn't exist then
                // this isn't really hurting anything)
                delete handlers[eventName];
            }
            return obj;
        }

        obj.emit = function(eventName) {
            // loop through all handlers for this event name and call them all
            for(var list = handlers[eventName], i = 0; list && list[i];) {
                list[i++].apply(obj, list.slice.call(arguments, 1));
            }
            return obj;
        }

        return obj;
    }
}

},{}],3:[function(require,module,exports){
"use strict";

var smokesignals = require('smokesignals');
var settings = require('./settings.js');

var cell = {
        /**
         * create instance of cell using protypal inheritance
         * @param {x,y}
         * @returns cell instance
         */
        create: function (x, y) {
            var self = Object.create(this);
            self.x = x;
            self.y = y;
            self.p = settings.cell.possibilities.slice(0);

            // make cell a event emitter
            smokesignals.convert(self);

            return self;
        },
        /**
         * remove possibily for this cell
         * @param {nr}
         * @returns [deleted item] 
         */
        del: function (nr) {
            var index = this.p.indexOf(nr);
            if (index >= 0) {
                this.p.splice(index, 1);
                if (this.p.length === 1) {
                    //console.log('one possibility left: now set value, emit change event');
                    this.emit('change', {target: this, value: this.getValue() });
                }
            } else {
                // would be better to prevent duplicate deletions by different sets, but for now allow it
                // throw 'IndexError: "' + nr + '"" does not exist in Array p:[' + this.p + ']';
            }
        },
        /**
         * removes all possibilities for this cell, expect for the passed nr
         * @param {exceptNr}
         * @returns [deleted item] 
         */
        delAll: function (exceptNr) {
            for (var i in settings.cell.possibilities) {
                if (settings.cell.possibilities[i] !== exceptNr) {
                    this.del(settings.cell.possibilities[i]);
                }
            }
        },
        setValue: function(nr) {
            this.value = nr;
            // console.log('setValue, now emit event, this.value:' + this.value);

            // value is known, now delete all other possibilities
            this.delAll(nr);
        },
        /** getter for the value of the cell
         * @param {}
         * @returns value
         */
        getValue: function () {
            if (this.p.length === 1) {
                return this.p[0];
            }
        }
};

module.exports = cell;
},{"./settings.js":7,"smokesignals":1}],4:[function(require,module,exports){
"use strict";
/*global document*/

var cell = require('./cell.js');
var set = require('./set.js');
var smokesignals = require('smokesignals');

/*
    -› x
  --------------
|  | (0,0) | (1,0) | (2,0) .. | (9,0)
v  | (0,1) | (1,1) | (2,1) .. | (9,1) 
   |  ..
y  | (0,9) | (1,9) | (2,9) .. | (9,9)

*/

var grid = {
        /**
         * initialize new instance
         * @param {}
         * @returns {Object}
         */
        data: [],
        rows: [],
        columns: [],
        blocks: [],
        gridEl: document.querySelector(".grid"),
        initialize: function () {
            // create sudoku rows, columns and blocks
            this.createRows();
            this.createColumns();
            this.createBlocks();

            // create sudoku cells
            this.createCells();

            // add values
            this.data[1][0].setValue(9);
            this.data[2][0].setValue(1);
            this.data[3][0].setValue(6);
            this.data[6][0].setValue(4);
            this.data[7][0].setValue(7);

            this.data[1][1].setValue(2);
            this.data[3][1].setValue(4);
            this.data[4][1].setValue(9);
            this.data[7][1].setValue(5);

            this.data[0][2].setValue(5);
            this.data[2][2].setValue(4);
            this.data[3][2].setValue(8);
            this.data[8][2].setValue(3);

            this.data[0][3].setValue(1);
            this.data[2][3].setValue(6);
            this.data[6][3].setValue(8);
            this.data[7][3].setValue(3);

            this.data[0][4].setValue(9);
            this.data[8][4].setValue(7);

            this.data[1][5].setValue(7);
            this.data[2][5].setValue(3);
            this.data[6][5].setValue(1);
            this.data[8][5].setValue(9);

            this.data[0][6].setValue(2);
            this.data[5][6].setValue(4);
            this.data[6][6].setValue(7);
            this.data[8][6].setValue(6);

            this.data[1][7].setValue(4);
            this.data[4][7].setValue(1);
            this.data[5][7].setValue(2);
            this.data[7][7].setValue(8);

            this.data[1][8].setValue(1);
            this.data[2][8].setValue(9);
            this.data[5][8].setValue(7);
            this.data[6][8].setValue(3);
            this.data[7][8].setValue(2);

            // console.log(this.columns);

            this.plotgrid();
        },
        /**
         * initializes this.data to a 9x9 2D array
         * @param {}
         * @returns {undefined}
         */
        createCells: function () {
            for (var i=0;i<=8;i++) {
                this.data.push([]);
                for (var j=0;j<=8;j++) {
                    
                    // create new cell instance
                    var c = cell.create(i, j);

                    // add cell to the sets
                    this.getRow(i,j).addCell(c);
                    this.getColumn(i,j).addCell(c);
                    this.getBlock(i,j).addCell(c);

                    // keep track of all cells
                    this.data[i][j] = c;
                }
            }
        },
        /**
         * create empty row sets
         */
        createRows: function () {
            for (var i=0;i<=8;i++) {
                var row = set.create(i, "row");
                row.i = i;
                this.rows.push(row);
            }
        },
        /**
         * create empty column sets
         */
        createColumns: function () {
            for (var i=0;i<=8;i++) {
                this.columns.push(set.create(i, "column"));
            }
        },
        /**
         * create empty block sets
         */
        createBlocks: function () {
            for (var i=0;i<=8;i++) {
                this.blocks.push(set.create(i, "block"));
            }
        },
        /**
         * get column by cell coordinate
         * @param {x, y}
         * @returns {set instance}
         */
        getColumn: function(x, y) {
            return this.columns[x];
        },
        /**
         * get row by cell coordinate
         * @param {x, y}
         * @returns {set instance}
         */
        getRow: function(x, y) {
            return this.rows[y];
        },
        /**
         * get row by cell coordinate
         * @param {x, y}
         * @returns {set instance}
         */
        getBlock: function(x, y) {

        /* return the block given cell coordinates
         * blocks in array [b0, b1, .., b8]
         * blocks in sudoku grid:
            |b0, b1, b2|
            |b3, b4, b5|
            |b6, b7, b8|
         * 
         */

            // first convert cell coordinates to block coordinates (0,0) -› (2,2) (divide by 3, floor result)
            // then to array index (block is wrapped modulo 3)
            return this.blocks[(Math.floor(y/3) * 3) + Math.floor(x/3)];
        },
        plotgrid: function() {
            var output = '<table class="sudoku">';
            for (var row=0;row<=8;row++) {
                output += "<tr>";
                for (var col=0;col<=8;col++) {
                    var cell = this.data[col][row];
                    var val = cell.getValue() || "";
                    var nrOptions = cell.p.length;
                    if (nrOptions >  1) {
                        output += "<td>" + val + "<small>(" + cell.p + ")</small>" + "</td>";                        
                    } else {
                        output += "<td>" + val + "</td>";
                    }

                }
                output += "</tr>";
            }
            output += "</table>";
            
            this.gridEl.innerHTML = output;
        }
};

module.exports = grid;
},{"./cell.js":3,"./set.js":6,"smokesignals":1}],5:[function(require,module,exports){
(function () {
    "use strict";
    /*global document*/
    var grid = require("./grid.js"),
        app = {
            /**
             * initialize new instance
             * @param {}
             * @returns {Object}
             */
            initialize: function () {
                grid.initialize();
            },
        };
    app.initialize();
}());
},{"./grid.js":4}],6:[function(require,module,exports){
"use strict";

var smokesignals = require('smokesignals');

var set = {
        /**
         * create instance of a set
         * @param {x,y}
         * @returns cell instance
         */
        create: function (id, type) {
            var self = Object.create(this);
            self.id = id;
            self.cells = [];
            self.type = type;
            return self;
        },
        addCell: function (cell) {
            // console.log('addCell, set.id:' + this.id + ' cell (' + cell.x + ', ' + cell.y + ')');
            this.cells.push(cell);

            // listen to change events of the cell
            cell.on('change', this.onCellChanged.bind(this));
        },
        onCellChanged: function (evt) {
            //console.log('set.onCellChanged, set.id: ' + this.id + ', type:' + this.type);
            //console.log(evt.target);
            //console.log(evt.value);

            // on cell changed: update all cells in this set, remove possibility
            for (var i in this.cells) {
                if (this.cells[i] !== evt.target) {
                    // console.log(this.cells[i]);
                    this.cells[i].del(evt.value);
                } else {
                    //console.log('no need to update the cell that caused the change');
                }

            }
        },
    };

module.exports = set;
},{"smokesignals":1}],7:[function(require,module,exports){
"use strict";

var settings = {
    cell: {possibilities: [1, 2, 3, 4, 5, 6, 7, 8, 9]}
};

module.exports = settings;
},{}]},{},[5])