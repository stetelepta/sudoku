(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
var existed = false;
var old;

if ('smokesignals' in global) {
    existed = true;
    old = global.smokesignals;
}

require('./smokesignals');

module.exports = smokesignals;

if (existed) {
    global.smokesignals = old;
}
else {
    delete global.smokesignals;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./smokesignals":2}],2:[function(require,module,exports){
smokesignals = {
    convert: function(obj, handlers) {
        // we store the list of handlers as a local variable inside the scope
        // so that we don't have to add random properties to the object we are
        // converting. (prefixing variables in the object with an underscore or
        // two is an ugly solution)
        // we declare the variable in the function definition to use two less
        // characters (as opposed to using 'var ').  I consider this an inelegant
        // solution since smokesignals.convert.length now returns 2 when it is
        // really 1, but doing this doesn't otherwise change the functionallity of
        // this module, so we'll go with it for now
        handlers = {};

        // add a listener
        obj.on = function(eventName, handler) {
            // either use the existing array or create a new one for this event
            (handlers[eventName] || (handlers[eventName] = []))
                // add the handler to the array
                .push(handler);

            return obj;
        }

        // add a listener that will only be called once
        obj.once = function(eventName, handler) {
            // create a wrapper listener, that will remove itself after it is called
            function wrappedHandler() {
                // remove ourself, and then call the real handler with the args
                // passed to this wrapper
                handler.apply(obj.off(eventName, wrappedHandler), arguments);
            }
            // in order to allow that these wrapped handlers can be removed by
            // removing the original function, we save a reference to the original
            // function
            wrappedHandler.h = handler;

            // call the regular add listener function with our new wrapper
            return obj.on(eventName, wrappedHandler);
        }

        // remove a listener
        obj.off = function(eventName, handler) {
            // loop through all handlers for this eventName, assuming a handler
            // was passed in, to see if the handler passed in was any of them so
            // we can remove it
            for (var list = handlers[eventName], i = 0; handler && list && list[i]; i++) {
                // either this item is the handler passed in, or this item is a
                // wrapper for the handler passed in.  See the 'once' function
                list[i] != handler && list[i].h != handler ||
                    // remove it!
                    list.splice(i--,1);
            }
            // if i is 0 (i.e. falsy), then there are no items in the array for this
            // event name (or the array doesn't exist)
            if (!i) {
                // remove the array for this eventname (if it doesn't exist then
                // this isn't really hurting anything)
                delete handlers[eventName];
            }
            return obj;
        }

        obj.emit = function(eventName) {
            // loop through all handlers for this event name and call them all
            for(var list = handlers[eventName], i = 0; list && list[i];) {
                list[i++].apply(obj, list.slice.call(arguments, 1));
            }
            return obj;
        }

        return obj;
    }
}

},{}],3:[function(require,module,exports){
"use strict";

var smokesignals = require('smokesignals');
var settings = require('./settings.js');

var cell = {
        /**
         * create instance of cell using protypal inheritance, see:
         * http://aaditmshah.github.io/why-prototypal-inheritance-matters/#constructors_vs_prototypes
         * @param {x,y}
         * @returns cell instance
         */
        create: function (x, y) {
            var self = Object.create(this);
            self.x = x;
            self.y = y;
            self.p = settings.cell.POSSIBILITIES.slice(0);

            // make cell a event emitter
            smokesignals.convert(self);

            return self;
        },
        /**
         * remove possibily for this cell
         * @param {nr}
         * @returns [deleted item] 
         */
        del: function (nr) {
            var index = this.p.indexOf(nr);
            if (index >= 0) {
                this.p.splice(index, 1);
                if (this.p.length === 1) {
                    console.log('one possibility left: now set value, emit change event');
                    this.emit('change', {target: this, value: this.getValue() });
                }
            } else {
                throw 'IndexError: "' + nr + '"" does not exist in Array p:[' + this.p + ']';
            }
        },
        /**
         * removes all cell.POSSIBILITIES for this cell, expect for passed nr
         * @param {exceptNr}
         * @returns [deleted item] 
         */
        delAll: function (exceptNr) {
            for (var i in settings.cell.POSSIBILITIES) {
                if (settings.cell.POSSIBILITIES[i] !== exceptNr) {
                    // console.log('now delete cell.POSSIBILITIES[i]:' + cell.POSSIBILITIES[i]);
                    this.del(settings.cell.POSSIBILITIES[i]);
                }
            }
        },
        setValue: function(nr) {
            this.value = nr;
            // console.log('setValue, now emit event, this.value:' + this.value);

            this.delAll(nr);
        },
        getValue: function () {
            if (this.p.length === 1) {
                return this.p[0];
            }
        }
};

module.exports = cell;
},{"./settings.js":7,"smokesignals":1}],4:[function(require,module,exports){
"use strict";
/*global document*/

var cell = require('./cell.js');
var set = require('./set.js');
var smokesignals = require('smokesignals');

/*
    -› x
  --------------
|  | (0,0) | (1,0) | (2,0) .. | (9,0)
v  | (0,1) | (1,1) | (2,1) .. | (9,1) 
   |  ..
y  | (0,9) | (1,9) | (2,9) .. | (9,9)

*/

var grid = {
        /**
         * initialize new instance
         * @param {}
         * @returns {Object}
         */
        data: [],
        rows: [],
        columns: [],
        blocks: [],
        initialize: function () {
            // create sudoku rows, columns and blocks
            this.createRows();
            this.createColumns();
            this.createBlocks();

            // create sudoku cells
            this.createCells();

            console.log(this.blocks);

            this.data[3][8].setValue(7);
            // this.test();
        },
        /**
         * initializes this.data to a 9x9 2D array
         * @param {}
         * @returns {undefined}
         */
        createCells: function () {
            for (var i=0;i<=8;i++) {
                this.data.push([]);
                for (var j=0;j<=8;j++) {
                    
                    // create new cell instance
                    var c = cell.create(i, j);

                    // add cell to the sets
                    this.getRow(i,j).addCell(c);
                    this.getColumn(i,j).addCell(c);
                    this.getBlock(i,j).addCell(c);

                    // keep track of all cells
                    this.data[i][j] = c;
                }
            }
        },
        createRows: function () {
            for (var i=0;i<=8;i++) {
                var row = set.create(i, "row");
                row.i = i;
                this.rows.push(row);
            }
        },
        createColumns: function () {
            for (var i=0;i<=8;i++) {
                this.columns.push(set.create(i, "column"));
            }
        },
        createBlocks: function () {
            for (var i=0;i<=8;i++) {
                this.blocks.push(set.create(i, "block"));
            }
        },
        getColumn: function(x, y) {
            return this.columns[x];
        },
        getRow: function(x, y) {
            return this.rows[y];
        },
        /* return the block given cell coordinates
         * blocks in array [b0, b1, .., b8]
         * blocks in sudoku grid:
            |b0, b1, b2|
            |b3, b4, b5|
            |b6, b7, b8|
         * 
         */
        getBlock: function(x, y) {
            // first convert cell coordinates to block coordinates (0,0) -› (2,2) (divide by 3, floor result)
            // then to array index (block is wrapped modulo 3)
            return this.blocks[(Math.floor(y/3) * 3) + Math.floor(x/3)];
        },
        test: function () {
            console.log(this.getColumn(4, 4));
            console.log(this.data[0][0]);
            console.log(this.data[0][1]);
        }
};

module.exports = grid;
},{"./cell.js":3,"./set.js":6,"smokesignals":1}],5:[function(require,module,exports){
(function () {
    "use strict";
    /*global document*/
    var grid = require("./grid.js"),
        app = {
            /**
             * initialize new instance
             * @param {}
             * @returns {Object}
             */

            initialize: function () {
                grid.initialize();
            },
        };
    app.initialize();
}());
},{"./grid.js":4}],6:[function(require,module,exports){
"use strict";

var smokesignals = require('smokesignals');

var set = {
        /**
         * create instance of a set
         * @param {x,y}
         * @returns cell instance
         */
        create: function (id, type) {
            var self = Object.create(this);
            self.id = id;
            self.cells = [];
            self.type = type;
            return self;
        },
        addCell: function (cell) {
            // console.log('addCell, set.id:' + this.id + ' cell (' + cell.x + ', ' + cell.y + ')');
            this.cells.push(cell);

            // listen to change events of the cell
            cell.on('change', this.onCellChanged.bind(this));
        },
        onCellChanged: function (evt) {
            console.log('set.onCellChanged:' + this.id + ', type:' + this.type);
            console.log(evt.target);
            console.log(evt.value);
        },
    };

module.exports = set;
},{"smokesignals":1}],7:[function(require,module,exports){
"use strict";

var settings = {
    cell: {POSSIBILITIES: [1, 2, 3, 4, 5, 6, 7, 8, 9]},
    set: {
        POSSIBILITIES: {
            1: [],
            2: [],
            3: [],
            4: [],
            5: [],
            6: [],
            7: [],
            8: [],
            9: []
        }
    }
};

module.exports = settings;
},{}]},{},[5])