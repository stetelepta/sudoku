(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
var existed = false;
var old;

if ('smokesignals' in global) {
    existed = true;
    old = global.smokesignals;
}

require('./smokesignals');

module.exports = smokesignals;

if (existed) {
    global.smokesignals = old;
}
else {
    delete global.smokesignals;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./smokesignals":2}],2:[function(require,module,exports){
smokesignals = {
    convert: function(obj, handlers) {
        // we store the list of handlers as a local variable inside the scope
        // so that we don't have to add random properties to the object we are
        // converting. (prefixing variables in the object with an underscore or
        // two is an ugly solution)
        // we declare the variable in the function definition to use two less
        // characters (as opposed to using 'var ').  I consider this an inelegant
        // solution since smokesignals.convert.length now returns 2 when it is
        // really 1, but doing this doesn't otherwise change the functionallity of
        // this module, so we'll go with it for now
        handlers = {};

        // add a listener
        obj.on = function(eventName, handler) {
            // either use the existing array or create a new one for this event
            (handlers[eventName] || (handlers[eventName] = []))
                // add the handler to the array
                .push(handler);

            return obj;
        }

        // add a listener that will only be called once
        obj.once = function(eventName, handler) {
            // create a wrapper listener, that will remove itself after it is called
            function wrappedHandler() {
                // remove ourself, and then call the real handler with the args
                // passed to this wrapper
                handler.apply(obj.off(eventName, wrappedHandler), arguments);
            }
            // in order to allow that these wrapped handlers can be removed by
            // removing the original function, we save a reference to the original
            // function
            wrappedHandler.h = handler;

            // call the regular add listener function with our new wrapper
            return obj.on(eventName, wrappedHandler);
        }

        // remove a listener
        obj.off = function(eventName, handler) {
            // loop through all handlers for this eventName, assuming a handler
            // was passed in, to see if the handler passed in was any of them so
            // we can remove it
            for (var list = handlers[eventName], i = 0; handler && list && list[i]; i++) {
                // either this item is the handler passed in, or this item is a
                // wrapper for the handler passed in.  See the 'once' function
                list[i] != handler && list[i].h != handler ||
                    // remove it!
                    list.splice(i--,1);
            }
            // if i is 0 (i.e. falsy), then there are no items in the array for this
            // event name (or the array doesn't exist)
            if (!i) {
                // remove the array for this eventname (if it doesn't exist then
                // this isn't really hurting anything)
                delete handlers[eventName];
            }
            return obj;
        }

        obj.emit = function(eventName) {
            // loop through all handlers for this event name and call them all
            for(var list = handlers[eventName], i = 0; list && list[i];) {
                list[i++].apply(obj, list.slice.call(arguments, 1));
            }
            return obj;
        }

        return obj;
    }
}

},{}],3:[function(require,module,exports){
"use strict";

var smokesignals = require('smokesignals');
var POSSIBILITIES = [1, 2, 3, 4, 5, 6, 7, 8, 9];

/*global document*/
var cell = {
        x: undefined,
        y: undefined,
        value: undefined,
        p: undefined,
        /**
         * create instance of cell using protypal inheritance, see:
         * http://aaditmshah.github.io/why-prototypal-inheritance-matters/#constructors_vs_prototypes
         * @param {x,y}
         * @returns cell instance
         */
        create: function (x, y) {
            var self = Object.create(this);
            self.initialize();
            self.x = x;
            self.y = y;
            return self;
        },
        /**
         * initialize new instance
         * @param {}
         * @returns {}
         */
        initialize: function () {
            // make cell a event emitter
            smokesignals.convert(this);

            this.p = POSSIBILITIES.slice(0);
        },
        /**
         * remove possibily for this cell
         * @param {nr}
         * @returns [deleted item] 
         */
        del: function (nr) {
            var index = this.p.indexOf(nr);
            if (index >= 0) {
                var removedItem = this.p.splice(index, 1);
                //console.log('removed: ' + removedItem + ', p:[' + this.p + "]");
                if (this.p.length === 1) {
                    console.log('one possibility left: now set value, emit change event');
                    this.emit('change', {target: this, value: this.p[0]});
                }
            } else {
                throw "IndexError: '" + nr + "' does not exist in Array p:[" + this.p + "]";
            }
        },
        /**
         * removes all possibilities for this cell, expect for passed nr
         * @param {exceptNr}
         * @returns [deleted item] 
         */
        delAll: function (exceptNr) {
            for (var i in POSSIBILITIES) {
                if (POSSIBILITIES[i] !== exceptNr) {
                    // console.log('now delete POSSIBILITIES[i]:' + POSSIBILITIES[i]);
                    this.del(POSSIBILITIES[i]);
                }
            }
        },
        setValue: function(nr) {
            this.value = nr;
            // console.log('setValue, now emit event, this.value:' + this.value);

            this.delAll(nr);
        }
};

module.exports = cell;
},{"smokesignals":1}],4:[function(require,module,exports){
"use strict";
/*global document*/

var cell = require('./cell.js');
var smokesignals = require('smokesignals');

var grid = {
        /**
         * initialize new instance
         * @param {}
         * @returns {Object}
         */
        data: [],
        initialize: function () {
            // console.log('grid.initialize');

            this.initializeData();
            // console.log(this.data[0][0]);

            this.data[0][1].setValue(7);

            // console.log(this.data[0][1]);
        },
        /**
         * initializes this.data to a 9x9 2D array
         * @param {}
         * @returns {undefined}
         */
        initializeData: function () {
            for (var i=0;i<=8;i++) {
                this.data.push([]);
                for (var j=0;j<=8;j++) {
                    var c = cell.create(i,j);
                    c.on('change', this.onCellChanged.bind(this));
                    this.data[i][j] = c;
                }
            }
        },
        onCellChanged: function (evt) {
            console.log('grid.onCellChanged');
            console.log(evt.target);  
            console.log(evt.value);  
        }
};

module.exports = grid;
},{"./cell.js":3,"smokesignals":1}],5:[function(require,module,exports){
(function () {
    "use strict";
    /*global document*/
    var grid = require("./grid.js"),
        app = {
            /**
             * initialize new instance
             * @param {}
             * @returns {Object}
             */

            initialize: function () {
                grid.initialize();
                this.addEventListeners();
            },
            /**
             * add event listeners for all elements in this view
             * @param {}
             * @returns {undefined}
             */
            addEventListeners: function () {
                console.log('addEventListeners');
            },
        };
    app.initialize();
}());
},{"./grid.js":4}]},{},[5])